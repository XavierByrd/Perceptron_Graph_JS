<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Custom GraphJS Library Test</title>
  </head>
  <body>
    <canvas id="canvas"></canvas>
    <script>
      // Get Canvas
      var c = document.getElementById("canvas");

      // Setup Canvas variables
      c.width = 300;
      c.height = 300;
      var origin = {x: c.width/2, y: c.height/2};
      var ctx = c.getContext("2d");

      // Setup grid variables
      var xaxis = 3;
      var yaxis = 10;
      var point = {x: null, y: null};

      // Integer from 1 to 100;
      // Most smooth = 1, Least Smooth = 100
      var smoothFactor = 1;

      // ticks
      var ticklength = 5;

      // Scales
      var xscale = origin.x/xaxis;
      var yscale = origin.y/yaxis;

      // Draw Axis'
      ctx.beginPath();
      // y axis
      ctx.moveTo(origin.x, 0);
      ctx.lineTo(origin.x, c.height);
      // X axis
      ctx.moveTo(0, origin.y);
      ctx.lineTo(c.width, origin.y);
      ctx.stroke();

      // START

      f = equation("(x * x * x)");

      point.x = convertToCanvasX(1);
      point.y = convertToCanvasY(f(1));

      /*console.log("Points");
      console.log("x: " + 1);
      console.log("y: " +f(1));
      console.log(point);
      console.log(convertToScaleX(point.x));
      console.log(convertToScaleY(point.y));*/

      console.log("scale: " + yscale);
      graph();
      drawTicks();
      var points = generateRandomPoints(20);
      drawPoints(points);

      // END

      /*
      colors
      Red - Alizarin Crimson #dd1e2f
      yellow orange - tulip tree - #ebb035
      light blue - cerulean - #06a2cb
      green blue - eucalyptus - #218559
      yellow orange - soft amber - #d0c6b1
      blue green - aztec - #192823

      */

      // Graph Function

      function evaluatePoint(point) {
        var evaluation = false;
        var evaluatedPoint = point;

        evaluatedPoint.isAboveEquation = (point.y > f(point.x));

        return evaluatedPoint;
      }

      function drawPoints(points) {
        for(var i = 0; i < points.length; i++) {
          points[i] = evaluatePoint(points[i]);
          ctx.beginPath();
          ctx.strokeStyle = "#192823";
          ctx.arc(convertToCanvasX(points[i].x), convertToCanvasY(points[i].y), 3, 0, 2*Math.PI);
          if(points[i].isAboveEquation) {
            ctx.fillStyle = "#218559";
          } else {
            ctx.fillStyle = "#dd1e2f";
          }
          ctx.fill();
          ctx.stroke();
        }
      }

      function generateRandomPoints(n) {
        var points = [];
        for(var i = 0; i < n; i++) {
          points.push(
            {
              x: (Math.random() * (xaxis * 2)) - xaxis,
              y: (Math.random() * (yaxis * 2)) - yaxis
            }
          );
        }
        return points;
      }

      function graph() {
        ctx.beginPath();
        ctx.strokeStyle = "#06a2cb";
        for(var x = -xaxis; x < xaxis; x += (smoothFactor * 0.01)) {
          //console.log("(" +x+","+f(x)+")\n" + "(" +convertToCanvasX(x)+","+convertToScaleY(f(x))+")\n");
          ctx.lineTo(convertToCanvasX(x) , convertToCanvasY(f(x)));
        }
        ctx.stroke();
      }

      function drawTicks() {
        ctx.strokeStyle = "black";
        ctx.beginPath();

        // Create ticks for x axis
        for(x = 0; x < origin.x; x += xscale) {
          ctx.moveTo(x, origin.x - ticklength/2);
          ctx.lineTo(x, origin.x + ticklength/2);
        }
        for(x = this.screen.width; x > origin.x; x -= xscale) {
          ctx.moveTo(x, origin.x - ticklength/2);
          ctx.lineTo(x, origin.x + ticklength/2);
        }

        // Create ticks for y axis
        for(y = 0; y < origin.y; y += yscale) {
          ctx.moveTo(origin.y - ticklength/2, y);
          ctx.lineTo(origin.y + ticklength/2, y);
        }
        for(y = this.screen.height; y > origin.y; y -= yscale) {
          ctx.moveTo(origin.y - ticklength/2, y);
          ctx.lineTo(origin.y + ticklength/2, y);
        }
        ctx.stroke();
      }

      // Important Functions
      function convertToCanvasX(x) {
        return origin.x + (x * xscale);
      }

      function convertToCanvasY(y) {
        return origin.y - (y * yscale);
      }

      function convertToScaleX(x) {
        return (x - origin.x) / xscale;
      }

      function convertToScaleY(y) {
        return (y + origin.y) / yscale;
      }

      function equation(equation) {
        return function(x) {
            return eval(equation);
        }
      }

    </script>
  </body>
</html>
